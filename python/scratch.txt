        +--------------------------------------------------------------+
        |                 ECDSA & Value Encoding/Decoding              |
        +--------------------------------------------------------------+
                          ^                        ^          ^
                          |                        |          |
        +---------------------------------------+  |  +----------------+
        |    elliptic curve group operations    |  |  | hash algorithm |
        +---------------------------------------+  |  +----------------+
                    ^                       ^      |
                    |                       |      |
        +----------------------------+    +----------------------------+
        |    modulo p arithmetics    |    |    modulo q arithmetics    |
        +----------------------------+    +----------------------------+
                    ^                                  ^
                    |                                  |
        +--------------------------------------------------------------+
        |                   big integer arithmetics                    |
        +--------------------------------------------------------------+

        ASN.1 decoding
        Public key decoding
        X.509 certificate decoding
        Finite field element decoding
        Elliptic curve group element decoding

        BitString -> BitString -> BitString -> UnsignedInteger -> GFq

         Message       Digest      Trimmed
                                    Digest

y = bit_length_of_unsigned_integer(x)

        PROCEDURE

                IF x = 0 THEN
                        y <- 0
                ELSE
                        y <- bit_length_of_natural_number(x)
                ENDIF

y = bit_length_of_natural_number(x)

        COMMENT

                y is the smallest natural number
                such that 2^y is greater than x

        PROCEDURE

                y <- 1
                WHILE 2^y <= x DO
                        y <- y + 1
                DONE


How to parse an X.509 certificate?

    https://en.wikipedia.org/wiki/X.509
    https://tools.ietf.org/html/rfc5280
    https://www.rfc-editor.org/errata_search.php?rfc=5280
    https://tools.ietf.org/html/rfc6818

Convert (k, l, m) into a public key, a signature, and an integer to be signed

        Parse an X.509 certificate      Extract the public key
    c' ----------------------------> c ------------------------> k
 OctetStr                          X509Cert                   OctetStr


       X9.62 public key decode
    k -------------------------> Q != 0
 OctetStr                        E


       ASN.1 decode
    l --------------> r != 0  and  s != 0
 OctetStr            GFq          GFq


       hash       keep at most qlen bits        to int       mod q
    m ------> m' ------------------------> m'' --------> h' -------> h
 OctetStr   OctetStr                      BitStr        UInt        GFq



E
    q                   an integer          a large prime
    G                   an element in E     the generator
    Z                   an element in E     the additive identity of E
    ( ... ) \in E       unary operator      check if X is an element of E
    ( ... ) == ( ... )  binary operator     check if X equals to Y
    -( ... )            unary operator      take the negative of X
    ( ... )[2]          unary operator      take the double of X
    ( ... ) + ( ... )   binary operator     add X and Y together
    ( ... )[ ... ]      binary operator     scalarmultiply X by n

additional procedures related to E

    Procedure SignatureGeneration and SignatureVerification both need these:

        get_the_x_coordinate_of_an_EC_point
        convert_an_underlying_field_element_to_the_outer_prime_field

    Procedure DecodeAPublicKeyFromAnOctetString needs these:

        convert_an_octet_string_to_an_underlying_field_element
        compute_the_y_coordinate_from_the_x_coordinate_and_a_parity_bit

